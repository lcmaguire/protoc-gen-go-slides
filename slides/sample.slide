# Writing protoc-plugins in go

## info

[https://github.com/lcmaguire](https://github.com/lcmaguire)

[linkedin](https://www.linkedin.com/in/liamcmaguire/)

## goal(s)

- protoc 
- protoc-plugin
- proto
- gRPC
- go

## proto

Protocol Buffers are language-neutral, platform-neutral extensible mechanisms for serializing structured data.

## proto fields 


.code ../proto/sample.proto /^message User/,/^}/

## go representation

.code ../proto/sample.pb.go /^type User/,/^}/



## proto encoding

the [encoding](https://protobuf.dev/programming-guides/encoding/) of proto messages is based upon field number 

- numbers from 1-15 take 1 byte to encode 
- numbers from 16 through 2047 take up 2 bytes


## proto encoding vs json comparison 

```proto 
message Account {
    string user_id = 1;
    string display_name = 2;
    int32 post_count = 3;
    bool active = 4;
    AccountType account_type = 5;
}
```

json representation which is 125B
```json 
{
    "user_id":"fcfca151-f887-41a3-88d4-98192efad2d9",
    "display_name":"Teresa Green",
    "post_count":100,
    "active":true,
    "account_type":1
}
```

when proto encoded is only 58 bytes
```
[10 36 54 100 49 99 102 100 51 97 45 51 55 101 100 45 52 48 99 57 45 98 48 57 49 45 99 100 100 99 52 53 102 57 51 56 99 100 18 12 84 101 114 101 115 97 32 71 114 101 101 110 24 100 32 1 40 1]
```


## oneofs

[oneofs](https://protobuf.dev/programming-guides/proto3/#oneof) are a way in which only one potential posibility is required

.code ../proto/sample.proto /^message Post/,/^}/

## oneofs go 

.code ../proto/sample.pb.go /^type Post /,/^}/

## oneofs go 1


.code ../proto/sample.pb.go /^type isPost_PostContent interface/,/^}/

```go
type Post_Audio struct {
	// audio post
	Audio *Audio `protobuf:"bytes,4,opt,name=audio,proto3,oneof"`
}

type Post_Video struct {
	// video post
	Video *Video `protobuf:"bytes,5,opt,name=video,proto3,oneof"`
}

type Post_Text struct {
	// text post
	Text string `protobuf:"bytes,6,opt,name=text,proto3,oneof"`
}

func (*Post_Audio) isPost_PostContent() {}

func (*Post_Video) isPost_PostContent() {}

func (*Post_Text) isPost_PostContent() {}
```

## real world scenario

```proto
message Payment {

  Account payment_origin = 1;

  google.Money amount = 2;

  ....  
  oneof payment_destination {
    Account account = 4;
    Bpay bpay = 5;
    PayID pay_id = 6
  }
}
```

## Helpful links

- [oneofs](https://protobuf.dev/programming-guides/proto3/#oneof)
- [Well known types](https://protobuf.dev/programming-guides/dos-donts/#well-known-common)
- [full list & mapping of scalar values](https://protobuf.dev/programming-guides/proto3/#scalar)
- [wellknown types](https://protobuf.dev/reference/protobuf/google.protobuf/)


## Services

a way to define API's 

.code ../proto/sample.proto /^service PostService {/,/^}/

Streaming declarations
``` proto
service StreamingExample {
  // server streaming RPC
  rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);
  // Client stream RPC
  rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);
  // Bidirectional stream RPC
  rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);
}

```

## show service gen code

Client Interface to implement

.code ../proto/sample_grpc.pb.go /^type PostServiceClient interface {/,/^}/

Server interface to implement 

.code ../proto/sample_grpc.pb.go /^type PostServiceServer interface {/,/^}/



## options / descriptors

// todo work this into differing examples.

[options](https://protobuf.dev/programming-guides/proto3/#options) a way to describe elements within your defined files, services, messages or fields.

don't change the overall meaning of a declaration, but may affect the way it is handled in a particular context.

- file descriptor (language specific package i.e. golang / java package)
- service descriptor some definition/behaviour for all methods in a service
- method descriptor scopes required, http format, idempotency
- message/field descriptor define validation rules for a field/message


## gRPC


- g(oogle, general-purpose, generic)

.image ./assets/grpc-definition.png

Remote Procedure Call

```go

res, err := grpcClient.CallRpc(ctx, request)

```

## gRPC 2

.image ./assets/grpc-flow.png

- simple service definition
- generates client and server interfaces for a large variety of languages
- streaming supported without any additional overhead


## protoc

compiler for proto files

.image ./assets/protocol-buffers-concepts.png

## protoc-plugin

something you can write which will plug in to the protoc compiler


## Why write a protoc-plugin?

- get go code from your defined messages
- gen documentation
- additional functionality
- custom business cases

##  Example plugins

- [go-setters](https://github.com/lcmaguire/protoc-gen-go-setters)
- [validate](https://github.com/bufbuild/protoc-gen-validate)
- [gen-doc](https://github.com/pseudomuto/protoc-gen-doc)
- [protoc-gen-bq-schema](https://github.com/GoogleCloudPlatform/protoc-gen-bq-schema)
- [protoc-gen-fieldmask](https://github.com/idodod/protoc-gen-fieldmask)


## invoking a plugin

taken from [protobuf.dev](https://protobuf.dev/getting-started/gotutorial/#compiling-protocol-buffers)
```
  protoc -I=$SRC_DIR --go_out=$DST_DIR $SRC_DIR/addressbook.proto
```

personal recomendation is to use buf cli 

```
    buf generate
```

<details><summary>buf.yaml</summary>

.code ./examples/buf.yaml

</details>


<details><summary>buf.gen.yaml</summary>

.code ./examples/buf.gen.yaml
</details>

## implementing a plugin


- must be an executable named `protoc-gen-{plugin_name}`
- will hang unless it recieves a [CodeGeneratorRequest](https://pkg.go.dev/google.golang.org/protobuf/types/pluginpb#CodeGeneratorRequest)
 

## Suggestions


- use [CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL](https://pkg.go.dev/google.golang.org/protobuf/types/pluginpb#CodeGeneratorResponse_Feature)


## Deets

- protogen.Options to parse any flags for any arguments
- Run for implementing all files

depending upon desired outcome iterate over
- files
- services
- messages
- fields of messages



##  Takeaways

- use buf cli 
- import proto 3 option 
- convert maps to ordered arrays when writing files (to have output deterministic)
- use File to limit generated code to current file
- iterating over fields e.t.c (mention covered by james)  


